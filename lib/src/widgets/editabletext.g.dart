// ignore_for_file: require_trailing_commas
// coverage:ignore-file

import 'package:flutter/widgets.dart';
import 'package:spot/spot.dart';

/// Matchers for [EditableText] auto-generated by spot
///
/// ```dart
/// spot<EditableText>().printMatchers();
/// ```
/// Matchers for the properties of [EditableText] provided via [Diagnosticable.debugFillProperties]
extension EditableTextMatcher on WidgetMatcher<EditableText> {
  /// Expects that controller of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasControllerWhere(
      MatchProp<TextEditingController> match) {
    return hasDiagnosticProp<TextEditingController>('controller', match);
  }

  /// Expects that controller of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasController(TextEditingController? value) {
    return hasDiagnosticProp<TextEditingController>(
        'controller', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that focusNode of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasFocusNodeWhere(MatchProp<FocusNode> match) {
    return hasDiagnosticProp<FocusNode>('focusNode', match);
  }

  /// Expects that focusNode of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasFocusNode(FocusNode? value) {
    return hasDiagnosticProp<FocusNode>(
        'focusNode', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that obscureText of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasObscureTextWhere(MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('obscureText', match);
  }

  /// Expects that obscureText of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasObscureText(bool? value) {
    return hasDiagnosticProp<bool>(
        'obscureText', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that readOnly of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasReadOnlyWhere(MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('readOnly', match);
  }

  /// Expects that readOnly of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasReadOnly(bool? value) {
    return hasDiagnosticProp<bool>(
        'readOnly', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that autocorrect of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasAutocorrectWhere(MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('autocorrect', match);
  }

  /// Expects that autocorrect of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasAutocorrect(bool? value) {
    return hasDiagnosticProp<bool>(
        'autocorrect', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that smartDashesType of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasSmartDashesTypeWhere(
      MatchProp<SmartDashesType> match) {
    return hasDiagnosticProp<SmartDashesType>('smartDashesType', match);
  }

  /// Expects that smartDashesType of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasSmartDashesType(SmartDashesType? value) {
    return hasDiagnosticProp<SmartDashesType>('smartDashesType',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that smartQuotesType of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasSmartQuotesTypeWhere(
      MatchProp<SmartQuotesType> match) {
    return hasDiagnosticProp<SmartQuotesType>('smartQuotesType', match);
  }

  /// Expects that smartQuotesType of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasSmartQuotesType(SmartQuotesType? value) {
    return hasDiagnosticProp<SmartQuotesType>('smartQuotesType',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that enableSuggestions of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasEnableSuggestionsWhere(MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('enableSuggestions', match);
  }

  /// Expects that enableSuggestions of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasEnableSuggestions(bool? value) {
    return hasDiagnosticProp<bool>('enableSuggestions',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that inherit of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasInheritWhere(MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('inherit', match);
  }

  /// Expects that inherit of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasInherit(bool? value) {
    return hasDiagnosticProp<bool>(
        'inherit', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that color of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasColorWhere(MatchProp<Color> match) {
    return hasDiagnosticProp<Color>('color', match);
  }

  /// Expects that color of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasColor(Color? value) {
    return hasDiagnosticProp<Color>(
        'color', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that backgroundColor of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasBackgroundColorWhere(MatchProp<Color> match) {
    return hasDiagnosticProp<Color>('backgroundColor', match);
  }

  /// Expects that backgroundColor of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasBackgroundColor(Color? value) {
    return hasDiagnosticProp<Color>('backgroundColor',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that family of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasFamilyWhere(MatchProp<String> match) {
    return hasDiagnosticProp<String>('family', match);
  }

  /// Expects that family of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasFamily(String? value) {
    return hasDiagnosticProp<String>(
        'family', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that familyFallback of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasFamilyFallbackWhere(MatchProp<String> match) {
    return hasDiagnosticProp<String>('familyFallback', match);
  }

  /// Expects that familyFallback of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasFamilyFallback(String? value) {
    return hasDiagnosticProp<String>('familyFallback',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that size of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasSizeWhere(MatchProp<double> match) {
    return hasDiagnosticProp<double>('size', match);
  }

  /// Expects that size of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasSize(double? value) {
    return hasDiagnosticProp<double>(
        'size', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that weight of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasWeightWhere(MatchProp<FontWeight> match) {
    return hasDiagnosticProp<FontWeight>('weight', match);
  }

  /// Expects that weight of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasWeight(FontWeight? value) {
    return hasDiagnosticProp<FontWeight>(
        'weight', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that style of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasStyleWhere(MatchProp<FontStyle> match) {
    return hasDiagnosticProp<FontStyle>('style', match);
  }

  /// Expects that style of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasStyle(FontStyle? value) {
    return hasDiagnosticProp<FontStyle>(
        'style', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that letterSpacing of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasLetterSpacingWhere(MatchProp<double> match) {
    return hasDiagnosticProp<double>('letterSpacing', match);
  }

  /// Expects that letterSpacing of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasLetterSpacing(double? value) {
    return hasDiagnosticProp<double>('letterSpacing',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that wordSpacing of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasWordSpacingWhere(MatchProp<double> match) {
    return hasDiagnosticProp<double>('wordSpacing', match);
  }

  /// Expects that wordSpacing of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasWordSpacing(double? value) {
    return hasDiagnosticProp<double>(
        'wordSpacing', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that baseline of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasBaselineWhere(MatchProp<TextBaseline> match) {
    return hasDiagnosticProp<TextBaseline>('baseline', match);
  }

  /// Expects that baseline of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasBaseline(TextBaseline? value) {
    return hasDiagnosticProp<TextBaseline>(
        'baseline', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that height of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasHeightWhere(MatchProp<double> match) {
    return hasDiagnosticProp<double>('height', match);
  }

  /// Expects that height of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasHeight(double? value) {
    return hasDiagnosticProp<double>(
        'height', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that leadingDistribution of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasLeadingDistributionWhere(
      MatchProp<TextLeadingDistribution> match) {
    return hasDiagnosticProp<TextLeadingDistribution>(
        'leadingDistribution', match);
  }

  /// Expects that leadingDistribution of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasLeadingDistribution(
      TextLeadingDistribution? value) {
    return hasDiagnosticProp<TextLeadingDistribution>('leadingDistribution',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that locale of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasLocaleWhere(MatchProp<Locale> match) {
    return hasDiagnosticProp<Locale>('locale', match);
  }

  /// Expects that locale of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasLocale(Locale? value) {
    return hasDiagnosticProp<Locale>(
        'locale', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that foreground of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasForegroundWhere(MatchProp<Paint> match) {
    return hasDiagnosticProp<Paint>('foreground', match);
  }

  /// Expects that foreground of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasForeground(Paint? value) {
    return hasDiagnosticProp<Paint>(
        'foreground', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that background of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasBackgroundWhere(MatchProp<Paint> match) {
    return hasDiagnosticProp<Paint>('background', match);
  }

  /// Expects that background of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasBackground(Paint? value) {
    return hasDiagnosticProp<Paint>(
        'background', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that textAlign of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasTextAlignWhere(MatchProp<TextAlign> match) {
    return hasDiagnosticProp<TextAlign>('textAlign', match);
  }

  /// Expects that textAlign of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasTextAlign(TextAlign? value) {
    return hasDiagnosticProp<TextAlign>(
        'textAlign', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that textDirection of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasTextDirectionWhere(
      MatchProp<TextDirection> match) {
    return hasDiagnosticProp<TextDirection>('textDirection', match);
  }

  /// Expects that textDirection of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasTextDirection(TextDirection? value) {
    return hasDiagnosticProp<TextDirection>('textDirection',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that textScaleFactor of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasTextScaleFactorWhere(MatchProp<double> match) {
    return hasDiagnosticProp<double>('textScaleFactor', match);
  }

  /// Expects that textScaleFactor of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasTextScaleFactor(double? value) {
    return hasDiagnosticProp<double>('textScaleFactor',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that maxLines of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasMaxLinesWhere(MatchProp<int> match) {
    return hasDiagnosticProp<int>('maxLines', match);
  }

  /// Expects that maxLines of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasMaxLines(int? value) {
    return hasDiagnosticProp<int>(
        'maxLines', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that minLines of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasMinLinesWhere(MatchProp<int> match) {
    return hasDiagnosticProp<int>('minLines', match);
  }

  /// Expects that minLines of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasMinLines(int? value) {
    return hasDiagnosticProp<int>(
        'minLines', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that expands of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasExpandsWhere(MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('expands', match);
  }

  /// Expects that expands of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasExpands(bool? value) {
    return hasDiagnosticProp<bool>(
        'expands', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that autofocus of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasAutofocusWhere(MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('autofocus', match);
  }

  /// Expects that autofocus of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasAutofocus(bool? value) {
    return hasDiagnosticProp<bool>(
        'autofocus', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that keyboardType of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasKeyboardTypeWhere(
      MatchProp<TextInputType> match) {
    return hasDiagnosticProp<TextInputType>('keyboardType', match);
  }

  /// Expects that keyboardType of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasKeyboardType(TextInputType? value) {
    return hasDiagnosticProp<TextInputType>(
        'keyboardType', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that scrollController of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasScrollControllerWhere(
      MatchProp<ScrollController> match) {
    return hasDiagnosticProp<ScrollController>('scrollController', match);
  }

  /// Expects that scrollController of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasScrollController(ScrollController? value) {
    return hasDiagnosticProp<ScrollController>('scrollController',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that scrollPhysics of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasScrollPhysicsWhere(
      MatchProp<ScrollPhysics> match) {
    return hasDiagnosticProp<ScrollPhysics>('scrollPhysics', match);
  }

  /// Expects that scrollPhysics of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasScrollPhysics(ScrollPhysics? value) {
    return hasDiagnosticProp<ScrollPhysics>('scrollPhysics',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that autofillHints of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasAutofillHintsWhere(
      MatchProp<Iterable<String>> match) {
    return hasDiagnosticProp<Iterable<String>>('autofillHints', match);
  }

  /// Expects that autofillHints of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasAutofillHints(Iterable<String>? value) {
    return hasDiagnosticProp<Iterable<String>>('autofillHints',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that textHeightBehavior of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasTextHeightBehaviorWhere(
      MatchProp<TextHeightBehavior> match) {
    return hasDiagnosticProp<TextHeightBehavior>('textHeightBehavior', match);
  }

  /// Expects that textHeightBehavior of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasTextHeightBehavior(TextHeightBehavior? value) {
    return hasDiagnosticProp<TextHeightBehavior>('textHeightBehavior',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that scribbleEnabled of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasScribbleEnabledWhere(MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('scribbleEnabled', match);
  }

  /// Expects that scribbleEnabled of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasScribbleEnabled(bool? value) {
    return hasDiagnosticProp<bool>('scribbleEnabled',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that enableIMEPersonalizedLearning of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasEnableIMEPersonalizedLearningWhere(
      MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('enableIMEPersonalizedLearning', match);
  }

  /// Expects that enableIMEPersonalizedLearning of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasEnableIMEPersonalizedLearning(bool? value) {
    return hasDiagnosticProp<bool>('enableIMEPersonalizedLearning',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that enableInteractiveSelection of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasEnableInteractiveSelectionWhere(
      MatchProp<bool> match) {
    return hasDiagnosticProp<bool>('enableInteractiveSelection', match);
  }

  /// Expects that enableInteractiveSelection of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasEnableInteractiveSelection(bool? value) {
    return hasDiagnosticProp<bool>('enableInteractiveSelection',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that undoController of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasUndoControllerWhere(
      MatchProp<UndoHistoryController> match) {
    return hasDiagnosticProp<UndoHistoryController>('undoController', match);
  }

  /// Expects that undoController of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasUndoController(UndoHistoryController? value) {
    return hasDiagnosticProp<UndoHistoryController>('undoController',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that spellCheckConfiguration of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasSpellCheckConfigurationWhere(
      MatchProp<SpellCheckConfiguration> match) {
    return hasDiagnosticProp<SpellCheckConfiguration>(
        'spellCheckConfiguration', match);
  }

  /// Expects that spellCheckConfiguration of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasSpellCheckConfiguration(
      SpellCheckConfiguration? value) {
    return hasDiagnosticProp<SpellCheckConfiguration>('spellCheckConfiguration',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Expects that contentCommitMimeTypes of [EditableText] matches the condition in [match]
  WidgetMatcher<EditableText> hasContentCommitMimeTypesWhere(
      MatchProp<List<String>> match) {
    return hasDiagnosticProp<List<String>>('contentCommitMimeTypes', match);
  }

  /// Expects that contentCommitMimeTypes of [EditableText] equals (==) [value]
  WidgetMatcher<EditableText> hasContentCommitMimeTypes(List<String>? value) {
    return hasDiagnosticProp<List<String>>('contentCommitMimeTypes',
        (it) => value == null ? it.isNull() : it.equals(value));
  }
}

/// Allows filtering [EditableText] by the properties provided via [Diagnosticable.debugFillProperties]
extension EditableTextSelector on WidgetSelector<EditableText> {
  /// Creates a [WidgetSelector] that finds all [EditableText] where controller matches the condition
  WidgetSelector<EditableText> whereController(
      MatchProp<TextEditingController> match) {
    return withDiagnosticProp<TextEditingController>('controller', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where controller equals (==) [value]
  WidgetSelector<EditableText> withController(TextEditingController? value) {
    return withDiagnosticProp<TextEditingController>(
        'controller', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where focusNode matches the condition
  WidgetSelector<EditableText> whereFocusNode(MatchProp<FocusNode> match) {
    return withDiagnosticProp<FocusNode>('focusNode', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where focusNode equals (==) [value]
  WidgetSelector<EditableText> withFocusNode(FocusNode? value) {
    return withDiagnosticProp<FocusNode>(
        'focusNode', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where obscureText matches the condition
  WidgetSelector<EditableText> whereObscureText(MatchProp<bool> match) {
    return withDiagnosticProp<bool>('obscureText', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where obscureText equals (==) [value]
  WidgetSelector<EditableText> withObscureText(bool? value) {
    return withDiagnosticProp<bool>(
        'obscureText', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where readOnly matches the condition
  WidgetSelector<EditableText> whereReadOnly(MatchProp<bool> match) {
    return withDiagnosticProp<bool>('readOnly', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where readOnly equals (==) [value]
  WidgetSelector<EditableText> withReadOnly(bool? value) {
    return withDiagnosticProp<bool>(
        'readOnly', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where autocorrect matches the condition
  WidgetSelector<EditableText> whereAutocorrect(MatchProp<bool> match) {
    return withDiagnosticProp<bool>('autocorrect', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where autocorrect equals (==) [value]
  WidgetSelector<EditableText> withAutocorrect(bool? value) {
    return withDiagnosticProp<bool>(
        'autocorrect', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where smartDashesType matches the condition
  WidgetSelector<EditableText> whereSmartDashesType(
      MatchProp<SmartDashesType> match) {
    return withDiagnosticProp<SmartDashesType>('smartDashesType', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where smartDashesType equals (==) [value]
  WidgetSelector<EditableText> withSmartDashesType(SmartDashesType? value) {
    return withDiagnosticProp<SmartDashesType>('smartDashesType',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where smartQuotesType matches the condition
  WidgetSelector<EditableText> whereSmartQuotesType(
      MatchProp<SmartQuotesType> match) {
    return withDiagnosticProp<SmartQuotesType>('smartQuotesType', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where smartQuotesType equals (==) [value]
  WidgetSelector<EditableText> withSmartQuotesType(SmartQuotesType? value) {
    return withDiagnosticProp<SmartQuotesType>('smartQuotesType',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where enableSuggestions matches the condition
  WidgetSelector<EditableText> whereEnableSuggestions(MatchProp<bool> match) {
    return withDiagnosticProp<bool>('enableSuggestions', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where enableSuggestions equals (==) [value]
  WidgetSelector<EditableText> withEnableSuggestions(bool? value) {
    return withDiagnosticProp<bool>('enableSuggestions',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where inherit matches the condition
  WidgetSelector<EditableText> whereInherit(MatchProp<bool> match) {
    return withDiagnosticProp<bool>('inherit', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where inherit equals (==) [value]
  WidgetSelector<EditableText> withInherit(bool? value) {
    return withDiagnosticProp<bool>(
        'inherit', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where color matches the condition
  WidgetSelector<EditableText> whereColor(MatchProp<Color> match) {
    return withDiagnosticProp<Color>('color', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where color equals (==) [value]
  WidgetSelector<EditableText> withColor(Color? value) {
    return withDiagnosticProp<Color>(
        'color', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where backgroundColor matches the condition
  WidgetSelector<EditableText> whereBackgroundColor(MatchProp<Color> match) {
    return withDiagnosticProp<Color>('backgroundColor', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where backgroundColor equals (==) [value]
  WidgetSelector<EditableText> withBackgroundColor(Color? value) {
    return withDiagnosticProp<Color>('backgroundColor',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where family matches the condition
  WidgetSelector<EditableText> whereFamily(MatchProp<String> match) {
    return withDiagnosticProp<String>('family', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where family equals (==) [value]
  WidgetSelector<EditableText> withFamily(String? value) {
    return withDiagnosticProp<String>(
        'family', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where familyFallback matches the condition
  WidgetSelector<EditableText> whereFamilyFallback(MatchProp<String> match) {
    return withDiagnosticProp<String>('familyFallback', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where familyFallback equals (==) [value]
  WidgetSelector<EditableText> withFamilyFallback(String? value) {
    return withDiagnosticProp<String>('familyFallback',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where size matches the condition
  WidgetSelector<EditableText> whereSize(MatchProp<double> match) {
    return withDiagnosticProp<double>('size', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where size equals (==) [value]
  WidgetSelector<EditableText> withSize(double? value) {
    return withDiagnosticProp<double>(
        'size', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where weight matches the condition
  WidgetSelector<EditableText> whereWeight(MatchProp<FontWeight> match) {
    return withDiagnosticProp<FontWeight>('weight', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where weight equals (==) [value]
  WidgetSelector<EditableText> withWeight(FontWeight? value) {
    return withDiagnosticProp<FontWeight>(
        'weight', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where style matches the condition
  WidgetSelector<EditableText> whereStyle(MatchProp<FontStyle> match) {
    return withDiagnosticProp<FontStyle>('style', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where style equals (==) [value]
  WidgetSelector<EditableText> withStyle(FontStyle? value) {
    return withDiagnosticProp<FontStyle>(
        'style', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where letterSpacing matches the condition
  WidgetSelector<EditableText> whereLetterSpacing(MatchProp<double> match) {
    return withDiagnosticProp<double>('letterSpacing', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where letterSpacing equals (==) [value]
  WidgetSelector<EditableText> withLetterSpacing(double? value) {
    return withDiagnosticProp<double>('letterSpacing',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where wordSpacing matches the condition
  WidgetSelector<EditableText> whereWordSpacing(MatchProp<double> match) {
    return withDiagnosticProp<double>('wordSpacing', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where wordSpacing equals (==) [value]
  WidgetSelector<EditableText> withWordSpacing(double? value) {
    return withDiagnosticProp<double>(
        'wordSpacing', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where baseline matches the condition
  WidgetSelector<EditableText> whereBaseline(MatchProp<TextBaseline> match) {
    return withDiagnosticProp<TextBaseline>('baseline', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where baseline equals (==) [value]
  WidgetSelector<EditableText> withBaseline(TextBaseline? value) {
    return withDiagnosticProp<TextBaseline>(
        'baseline', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where height matches the condition
  WidgetSelector<EditableText> whereHeight(MatchProp<double> match) {
    return withDiagnosticProp<double>('height', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where height equals (==) [value]
  WidgetSelector<EditableText> withHeight(double? value) {
    return withDiagnosticProp<double>(
        'height', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where leadingDistribution matches the condition
  WidgetSelector<EditableText> whereLeadingDistribution(
      MatchProp<TextLeadingDistribution> match) {
    return withDiagnosticProp<TextLeadingDistribution>(
        'leadingDistribution', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where leadingDistribution equals (==) [value]
  WidgetSelector<EditableText> withLeadingDistribution(
      TextLeadingDistribution? value) {
    return withDiagnosticProp<TextLeadingDistribution>('leadingDistribution',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where locale matches the condition
  WidgetSelector<EditableText> whereLocale(MatchProp<Locale> match) {
    return withDiagnosticProp<Locale>('locale', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where locale equals (==) [value]
  WidgetSelector<EditableText> withLocale(Locale? value) {
    return withDiagnosticProp<Locale>(
        'locale', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where foreground matches the condition
  WidgetSelector<EditableText> whereForeground(MatchProp<Paint> match) {
    return withDiagnosticProp<Paint>('foreground', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where foreground equals (==) [value]
  WidgetSelector<EditableText> withForeground(Paint? value) {
    return withDiagnosticProp<Paint>(
        'foreground', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where background matches the condition
  WidgetSelector<EditableText> whereBackground(MatchProp<Paint> match) {
    return withDiagnosticProp<Paint>('background', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where background equals (==) [value]
  WidgetSelector<EditableText> withBackground(Paint? value) {
    return withDiagnosticProp<Paint>(
        'background', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where textAlign matches the condition
  WidgetSelector<EditableText> whereTextAlign(MatchProp<TextAlign> match) {
    return withDiagnosticProp<TextAlign>('textAlign', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where textAlign equals (==) [value]
  WidgetSelector<EditableText> withTextAlign(TextAlign? value) {
    return withDiagnosticProp<TextAlign>(
        'textAlign', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where textDirection matches the condition
  WidgetSelector<EditableText> whereTextDirection(
      MatchProp<TextDirection> match) {
    return withDiagnosticProp<TextDirection>('textDirection', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where textDirection equals (==) [value]
  WidgetSelector<EditableText> withTextDirection(TextDirection? value) {
    return withDiagnosticProp<TextDirection>('textDirection',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where textScaleFactor matches the condition
  WidgetSelector<EditableText> whereTextScaleFactor(MatchProp<double> match) {
    return withDiagnosticProp<double>('textScaleFactor', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where textScaleFactor equals (==) [value]
  WidgetSelector<EditableText> withTextScaleFactor(double? value) {
    return withDiagnosticProp<double>('textScaleFactor',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where maxLines matches the condition
  WidgetSelector<EditableText> whereMaxLines(MatchProp<int> match) {
    return withDiagnosticProp<int>('maxLines', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where maxLines equals (==) [value]
  WidgetSelector<EditableText> withMaxLines(int? value) {
    return withDiagnosticProp<int>(
        'maxLines', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where minLines matches the condition
  WidgetSelector<EditableText> whereMinLines(MatchProp<int> match) {
    return withDiagnosticProp<int>('minLines', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where minLines equals (==) [value]
  WidgetSelector<EditableText> withMinLines(int? value) {
    return withDiagnosticProp<int>(
        'minLines', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where expands matches the condition
  WidgetSelector<EditableText> whereExpands(MatchProp<bool> match) {
    return withDiagnosticProp<bool>('expands', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where expands equals (==) [value]
  WidgetSelector<EditableText> withExpands(bool? value) {
    return withDiagnosticProp<bool>(
        'expands', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where autofocus matches the condition
  WidgetSelector<EditableText> whereAutofocus(MatchProp<bool> match) {
    return withDiagnosticProp<bool>('autofocus', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where autofocus equals (==) [value]
  WidgetSelector<EditableText> withAutofocus(bool? value) {
    return withDiagnosticProp<bool>(
        'autofocus', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where keyboardType matches the condition
  WidgetSelector<EditableText> whereKeyboardType(
      MatchProp<TextInputType> match) {
    return withDiagnosticProp<TextInputType>('keyboardType', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where keyboardType equals (==) [value]
  WidgetSelector<EditableText> withKeyboardType(TextInputType? value) {
    return withDiagnosticProp<TextInputType>(
        'keyboardType', (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where scrollController matches the condition
  WidgetSelector<EditableText> whereScrollController(
      MatchProp<ScrollController> match) {
    return withDiagnosticProp<ScrollController>('scrollController', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where scrollController equals (==) [value]
  WidgetSelector<EditableText> withScrollController(ScrollController? value) {
    return withDiagnosticProp<ScrollController>('scrollController',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where scrollPhysics matches the condition
  WidgetSelector<EditableText> whereScrollPhysics(
      MatchProp<ScrollPhysics> match) {
    return withDiagnosticProp<ScrollPhysics>('scrollPhysics', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where scrollPhysics equals (==) [value]
  WidgetSelector<EditableText> withScrollPhysics(ScrollPhysics? value) {
    return withDiagnosticProp<ScrollPhysics>('scrollPhysics',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where autofillHints matches the condition
  WidgetSelector<EditableText> whereAutofillHints(
      MatchProp<Iterable<String>> match) {
    return withDiagnosticProp<Iterable<String>>('autofillHints', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where autofillHints equals (==) [value]
  WidgetSelector<EditableText> withAutofillHints(Iterable<String>? value) {
    return withDiagnosticProp<Iterable<String>>('autofillHints',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where textHeightBehavior matches the condition
  WidgetSelector<EditableText> whereTextHeightBehavior(
      MatchProp<TextHeightBehavior> match) {
    return withDiagnosticProp<TextHeightBehavior>('textHeightBehavior', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where textHeightBehavior equals (==) [value]
  WidgetSelector<EditableText> withTextHeightBehavior(
      TextHeightBehavior? value) {
    return withDiagnosticProp<TextHeightBehavior>('textHeightBehavior',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where scribbleEnabled matches the condition
  WidgetSelector<EditableText> whereScribbleEnabled(MatchProp<bool> match) {
    return withDiagnosticProp<bool>('scribbleEnabled', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where scribbleEnabled equals (==) [value]
  WidgetSelector<EditableText> withScribbleEnabled(bool? value) {
    return withDiagnosticProp<bool>('scribbleEnabled',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where enableIMEPersonalizedLearning matches the condition
  WidgetSelector<EditableText> whereEnableIMEPersonalizedLearning(
      MatchProp<bool> match) {
    return withDiagnosticProp<bool>('enableIMEPersonalizedLearning', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where enableIMEPersonalizedLearning equals (==) [value]
  WidgetSelector<EditableText> withEnableIMEPersonalizedLearning(bool? value) {
    return withDiagnosticProp<bool>('enableIMEPersonalizedLearning',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where enableInteractiveSelection matches the condition
  WidgetSelector<EditableText> whereEnableInteractiveSelection(
      MatchProp<bool> match) {
    return withDiagnosticProp<bool>('enableInteractiveSelection', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where enableInteractiveSelection equals (==) [value]
  WidgetSelector<EditableText> withEnableInteractiveSelection(bool? value) {
    return withDiagnosticProp<bool>('enableInteractiveSelection',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where undoController matches the condition
  WidgetSelector<EditableText> whereUndoController(
      MatchProp<UndoHistoryController> match) {
    return withDiagnosticProp<UndoHistoryController>('undoController', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where undoController equals (==) [value]
  WidgetSelector<EditableText> withUndoController(
      UndoHistoryController? value) {
    return withDiagnosticProp<UndoHistoryController>('undoController',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where spellCheckConfiguration matches the condition
  WidgetSelector<EditableText> whereSpellCheckConfiguration(
      MatchProp<SpellCheckConfiguration> match) {
    return withDiagnosticProp<SpellCheckConfiguration>(
        'spellCheckConfiguration', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where spellCheckConfiguration equals (==) [value]
  WidgetSelector<EditableText> withSpellCheckConfiguration(
      SpellCheckConfiguration? value) {
    return withDiagnosticProp<SpellCheckConfiguration>(
        'spellCheckConfiguration',
        (it) => value == null ? it.isNull() : it.equals(value));
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where contentCommitMimeTypes matches the condition
  WidgetSelector<EditableText> whereContentCommitMimeTypes(
      MatchProp<List<String>> match) {
    return withDiagnosticProp<List<String>>('contentCommitMimeTypes', match);
  }

  /// Creates a [WidgetSelector] that finds all [EditableText] where contentCommitMimeTypes equals (==) [value]
  WidgetSelector<EditableText> withContentCommitMimeTypes(List<String>? value) {
    return withDiagnosticProp<List<String>>('contentCommitMimeTypes',
        (it) => value == null ? it.isNull() : it.equals(value));
  }
}
